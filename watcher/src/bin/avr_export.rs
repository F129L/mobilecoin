// Copyright (c) 2018-2022 The MobileCoin Foundation

//! A utility for exporting the history of Attestation Verification
//! Reports generated by MobileCoin consensus nodes

use clap::Parser;
use mc_blockchain_validators::metadata::avr::{AvrConfig, AvrConfigRecord};
use mc_common::{
    logger::{create_app_logger, o},
    ResponderId,
};
use mc_crypto_keys::Ed25519Public;
use mc_watcher::{error::WatcherDBError, watcher_db::WatcherDB};
use std::{fs, path::PathBuf};
use url::Url;

/// Command line configuration.
#[derive(Parser)]
#[clap(
    name = "mc-watcher-avr-export",
    about = "A utility for exporting the history of MobileCoin consensus enclave AVRs"
)]
pub struct Config {
    /// Path to watcher db (lmdb).
    #[clap(
        long,
        default_value = "watcher-db",
        parse(from_os_str),
        env = "MC_WATCHER_DB"
    )]
    pub watcher_db: PathBuf,

    /// Path for the avr-history.toml & avr-history.json bootstrap files to be
    /// written.
    #[clap(
        long,
        default_value = "",
        parse(from_os_str),
        env = "MC_AVR_HISTORY_PATH"
    )]
    pub avr_history: PathBuf,
}

fn main() {
    let (logger, _global_logger_guard) = create_app_logger(o!());

    let mut config = Config::parse();
    config.avr_history.set_file_name("avr_history");
    let watcher_db =
        WatcherDB::open_ro(&config.watcher_db, logger).expect("Failed opening watcher db");
    let mut avr_reports = AvrConfig::default();

    // Get all of the latest synced blocks
    let last_synced_blocks = watcher_db.last_synced_blocks().unwrap();

    // Find where the signing keys changed and fetch the AVRs for those keys
    for (tx_src_url, max_block_index) in last_synced_blocks.iter() {
        let max_block_count = max_block_index.map_or_else(|| 0, |idx| idx + 1);
        let mut cur_start_index = 0;
        let mut cur_end_index = 0;
        let mut cur_signer = None;
        for block_index in 0..max_block_count {
            let signer = match watcher_db.get_block_data(tx_src_url, block_index) {
                Ok(block_data) => block_data.signature().map(|sig| *sig.signer()),
                Err(WatcherDBError::NotFound) => None,
                Err(err) => {
                    panic!(
                        "Failed getting block {}@{}: {:?}",
                        cur_start_index, tx_src_url, err
                    );
                }
            };

            if signer == cur_signer {
                cur_end_index += 1;
            } else {
                let record = generate_avr_record(
                    &watcher_db,
                    tx_src_url,
                    cur_start_index,
                    cur_end_index,
                    &signer,
                );
                avr_reports.avr_records.push(record);
                cur_start_index = block_index;
                cur_end_index = block_index;
                cur_signer = signer;
            }
        }
    }

    // Export the AVR history to toml and write it to disk
    let avr_history_toml = toml::to_string_pretty(&avr_reports).unwrap();
    let avr_history_json = serde_json::to_string_pretty(&avr_reports).unwrap();
    println!("Historical AVR Results: \n\n{}", avr_history_toml);
    config.avr_history.set_extension("toml");
    fs::write(&config.avr_history, avr_history_toml).unwrap();
    config.avr_history.set_extension("json");
    fs::write(&config.avr_history, avr_history_json).unwrap();
}

// Replace the archive prefix with the consensus prefix (mc://)
fn create_responder_id(url: &Url) -> ResponderId {
    if url.scheme() == "https" {
        return ResponderId(format!("mc:/{}", url.path()));
    };
    ResponderId(url.to_string())
}

// Generate historical AVR record in format suggested by draft MCIP #43
// from watcherdb data
fn generate_avr_record(
    watcher_db: &WatcherDB,
    tx_src_url: &Url,
    start_block: u64,
    end_block: u64,
    signer: &Option<Ed25519Public>,
) -> AvrConfigRecord {
    let mut avr_record = AvrConfigRecord::new(
        &create_responder_id(tx_src_url),
        start_block,
        Some(end_block),
        None,
    );
    let reports = match signer {
        Some(signer) => watcher_db
            .get_verification_reports_for_signer(signer)
            .expect("Could not get verification reports for signer"),
        None => return avr_record,
    };

    // Should only have one URL associated with this signer
    match reports.len() {
        0 => avr_record,
        1 => match reports.get(tx_src_url) {
            Some(reports) => {
                // Should only have one report associated with the signer+url pair
                match reports.len() {
                    0 => avr_record,
                    1 => {
                        avr_record.avr = reports[0].as_ref().cloned();
                        avr_record
                    }
                    _ => panic!(
                        "fatal: multiple AVRs found for signing key {:?} from {:?}",
                        signer, tx_src_url
                    ),
                }
            }
            None => avr_record,
        },
        // If there are multiple reports available, DO NOT boostrap from it
        _ => panic!(
            "fatal: multiple AVRs found for signing key {:?} from {:?}",
            signer, tx_src_url
        ),
    }
}
