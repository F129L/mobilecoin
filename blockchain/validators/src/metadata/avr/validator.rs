// Copyright (c) 2018-2022 The MobileCoin Foundation

//! Types for reading and writing historical Intel Attestation
//! Verification Reports from MobileCoin consensus enclaves

use crate::ParseError;
use mc_attest_verifier::Verifier;
use mc_blockchain_types::{BlockIndex, VerificationReport};
use mc_common::ResponderId;
use mc_crypto_keys::Ed25519Public;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ops::RangeInclusive, path::Path};

/// Object representing history of attestation verification reports
/// (AVR) for all consensus nodes mapped by block signing key.
///
/// The following details relevant details should be noted:
/// 1. The Block Signing key is derived from the AVR
/// 2. There is a unique a unique AVR for every enclave session. If
/// a consensus node restarts a new AVR and block signing key will
/// be generated. This results in a unique block signing key and AVR
/// for each contiguous range of blocks.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AvrValidator {
    /// Map of block signing key to AVR Record
    pub avr_history: HashMap<Ed25519Public, AvrValidationRecord>,

    /// Verifier used to validate AVRs were generated by an properly
    /// signed enclave. This is done using offline records located
    /// in the attest/verifier/data/ directory.
    pub avr_verifier: Verifier,
}

/// Struct representing the range of blocks and responder an Intel
/// Attestation Verification Report was valid for.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AvrValidationRecord {
    /// Block range the AVR was valid for
    pub block_range: RangeInclusive<BlockIndex>,

    /// Responder ID of the consensus node containing the enclave
    /// session that generated the AVR.
    pub responder_id: ResponderId,

    /// Intel Attestation Verification Report for the enclave session
    pub avr: VerificationReport,
}

impl AvrValidator {
    /// Create AVR validate from AVR history config file
    pub fn load(path: impl AsRef<Path>) -> Result<Self, ParseError> {
        let mut avr_history = crate::metadata::avr::AvrConfig::load(path)?;
        Ok(avr_history.create_avr_validator()?)
    }
}
